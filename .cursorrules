# IdaraOS - Cursor AI Rules

## Project Context

This is IdaraOS, an internal operations platform built with Next.js, featuring People & HR, Assets, Security, Workflows, and more.

## Core Principles

1. **Primitives Over Custom**: Use DataTable, FormBuilder, PageShell, ResourceLayout, FormDrawer
2. **RBAC Always**: Check permissions with `usePermission()` and `<Protected>`
3. **No New Dependencies**: Unless approved in `docs/DECISIONS.md`
4. **Type Safety**: Zod schemas for validation, TypeScript strict mode
5. **Drizzle ORM**: Schema in `lib/db/schema/`, use `db:push` for prototyping, `db:migrate` for production

## File Structure

- `apps/web/lib/db/schema/` - Database schema definitions (Drizzle)
- `apps/web/lib/api/` - React Query hooks and API utilities
- `apps/web/app/api/` - API route handlers
- `apps/web/components/primitives/` - Reusable UI components
- `apps/web/lib/rbac/` - Permission system
- `apps/web/lib/navigation/` - Route config

## Development Workflow

### When Adding a Module:

1. Create schema in `lib/db/schema/<entity>.ts`
2. Run `pnpm db:push` to apply schema (prototyping) or `pnpm db:generate && pnpm db:migrate:run` (production)
3. Create API routes in `app/api/<area>/<entity>/route.ts`
4. Create React Query hooks in `lib/api/<entity>.ts`
5. Create list page using DataTable primitive
6. Create detail page using ResourceLayout
7. Add FormDrawer for create/edit
8. Add to navigation in `lib/navigation/routes.ts` and `components/app-sidebar.tsx`
9. Add permissions to RBAC (`scripts/sync-rbac-permissions.ts`)

### When Editing Code:

- ✅ Use TypeScript strict mode
- ✅ Use Tailwind for styling
- ✅ Use semantic HTML
- ✅ Add permission checks
- ✅ Add loading states
- ✅ Use Zod for validation

## Key Files to Reference

- `docs/DECISIONS.md` - Technical decisions (frozen)
- `docs/DATABASE_MIGRATIONS.md` - Migration workflow
- `docs/modules/` - Module architecture documentation

## Code Style

- Use "use client" directive for interactive components
- Prefer arrow functions for components
- Use const, avoid let
- Destructure props
- Add JSDoc for exported functions
- Use descriptive variable names

## Data Fetching

- Use React Query hooks from `lib/api/`
- Pattern: `use<Entity>List()`, `use<Entity>Detail()`, `useCreate<Entity>()`, etc.
- Always handle loading and error states
- Show toast notifications on success/error

## Forms

- Use FormDrawer with Zod schema
- Add field-level validation errors
- Disable submit during submission
- Show success toast on completion

## Tables

- Use DataTable or DataTableAdvanced primitives
- Enable column visibility, filters, sorting
- Add CSV export when relevant
- Use faceted filters for enum columns

## Security

- Check permissions with `usePermission(resource, action)`
- Wrap protected UI in `<Protected>` component
- Never trust client-only checks
- Always validate server-side
- Scope all queries by org_id

## Accessibility

- Use semantic HTML elements
- Add ARIA labels where needed
- Support keyboard navigation
- Ensure focus management in modals
- Test color contrast

## Testing

- Write E2E tests for critical flows
- Test validation edge cases
- Test permission checks
- Use data-testid for stable selectors

## Don'ts

- ❌ Don't add new npm packages without approval
- ❌ Don't use inline styles
- ❌ Don't skip permission checks
- ❌ Don't use `any` types
- ❌ Don't hardcode data (use API calls)

## Commands

```bash
# Run dev server (Docker)
pnpm docker:dev

# Push schema changes (prototyping)
pnpm db:push

# Generate and run migrations (production)
pnpm db:generate
pnpm db:migrate:run

# Sync RBAC permissions
pnpm db:sync-rbac

# Run tests
pnpm test        # Vitest
pnpm test:e2e    # Playwright

# Lint
pnpm lint
```

## When Stuck

1. Check `docs/DECISIONS.md` for technical guidance
2. Check `docs/DATABASE_MIGRATIONS.md` for migration help
3. Look at existing modules: people/directory, workflows/templates
4. Review `docs/modules/` for architecture documentation

---

**Remember**: Schema first, API second, UI last. Keep it type-safe, consistent, and performant.
