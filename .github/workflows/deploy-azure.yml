# =============================================================================
# IdaraOS - Deploy to Azure Container Apps
# =============================================================================
# Triggered on: Manual dispatch only
# Actions: Deploy to Azure Container Apps with environment-specific config
# =============================================================================

name: Deploy to Azure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
        default: dev

env:
  APP_NAME: idaraos
  LOCATION: uks
  SEQUENCE: "001"

jobs:
  # ===========================================================================
  # Deploy to Development (manual only)
  # ===========================================================================
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'dev'

    environment:
      name: dev
      url: ${{ steps.deploy.outputs.app_url }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: |
          az acr login --name ${{ secrets.ACR_NAME }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: deployment/docker/Dockerfile
          push: true
          tags: |
            ${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ github.sha }}
            ${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:dev-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Get ACR credentials
        id: acr-creds
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query "passwords[0].value" -o tsv)
          echo "::add-mask::$ACR_PASSWORD"
          echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
          echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT

      - name: Get secrets from Key Vault
        id: secrets
        run: |
          KV_NAME="kv-${{ env.APP_NAME }}-dev-${{ env.SEQUENCE }}"
          JWT_SECRET=$(az keyvault secret show --vault-name $KV_NAME --name jwt-secret --query value -o tsv)
          ENCRYPTION_KEY=$(az keyvault secret show --vault-name $KV_NAME --name encryption-key --query value -o tsv)
          PG_PASSWORD=$(az keyvault secret show --vault-name $KV_NAME --name pg-password --query value -o tsv)
          echo "::add-mask::$JWT_SECRET"
          echo "::add-mask::$ENCRYPTION_KEY"
          echo "::add-mask::$PG_PASSWORD"
          echo "jwt_secret=$JWT_SECRET" >> $GITHUB_OUTPUT
          echo "encryption_key=$ENCRYPTION_KEY" >> $GITHUB_OUTPUT
          echo "pg_password=$PG_PASSWORD" >> $GITHUB_OUTPUT

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile

      - name: Push database schema
        env:
          CI: "true"
          FORCE_COLOR: "0"
          NODE_ENV: "production"
        run: |
          PSQL="psql-${{ env.APP_NAME }}-dev-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  IdaraOS Database Schema Push"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          # Prototyping mode: Drop all tables if schema mismatch detected
          # This avoids interactive prompts from drizzle-kit push
          echo "ðŸ” Checking for schema mismatches..."
          MISMATCH=$(node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            pool.query(\"SELECT column_name FROM information_schema.columns WHERE table_name = 'people_persons' AND column_name IN ('role', 'team')\")
              .then(r => { console.log(r.rows.length > 0 ? 'true' : 'false'); pool.end(); })
              .catch(() => { console.log('false'); pool.end(); });
          ")
          
          if [ "$MISMATCH" = "true" ]; then
            echo "âš ï¸  Old schema detected (role/team as text columns)"
            echo "ðŸ—‘ï¸  Dropping all tables for clean schema push (prototyping mode)..."
            node -e "
              const { Pool } = require('pg');
              const pool = new Pool({ connectionString: process.env.DATABASE_URL });
              pool.query('DROP SCHEMA public CASCADE; CREATE SCHEMA public;')
                .then(() => { console.log('Schema reset complete'); pool.end(); })
                .catch(e => { console.error('Error:', e.message); pool.end(); process.exit(1); });
            "
          fi
          
          echo "ðŸ“‹ Pushing schema to database (prototyping mode)..."
          # Install expect for handling interactive prompts
          sudo apt-get install -y expect > /dev/null 2>&1 || true
          
          # Use expect to handle drizzle-kit's interactive prompts
          # This sends Enter to accept default selections
          expect -c '
            set timeout 300
            spawn npx drizzle-kit push --force
            expect {
              "truncate" { send "\r"; exp_continue }
              "Do you" { send "\r"; exp_continue }
              "?" { send "\r"; exp_continue }
              eof { exit 0 }
              timeout { exit 0 }
            }
          ' || true
          
          echo ""
          echo "âœ… Database schema push completed!"
          
      - name: Verify database schema
        run: |
          PSQL="psql-${{ env.APP_NAME }}-dev-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          
          echo "Verifying database schema..."
          node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            async function verify() {
              try {
                // Check core tables
                await pool.query('SELECT 1 FROM core_organizations LIMIT 1');
                console.log('âœ… core_organizations table exists');
                
                await pool.query('SELECT 1 FROM rbac_user_roles LIMIT 1');
                console.log('âœ… rbac_user_roles table exists');
                
                // Check people_persons has required columns
                const result = await pool.query(\`
                  SELECT column_name FROM information_schema.columns 
                  WHERE table_name = 'people_persons' 
                  AND column_name IN ('role_id', 'team_id', 'source', 'entra_created_at', 'hire_date')
                \`);
                const columns = result.rows.map(r => r.column_name);
                
                const required = ['role_id', 'team_id', 'source', 'entra_created_at', 'hire_date'];
                const missing = required.filter(c => !columns.includes(c));
                
                if (missing.length > 0) {
                  console.error('âŒ Missing columns in people_persons:', missing.join(', '));
                  process.exit(1);
                }
                
                // Check related tables exist
                await pool.query('SELECT 1 FROM people_teams LIMIT 1');
                console.log('âœ… people_teams table exists');
                
                await pool.query('SELECT 1 FROM people_organizational_roles LIMIT 1');
                console.log('âœ… people_organizational_roles table exists');
                
                console.log('âœ… people_persons has all required columns');
                
                // Check documentation tables exist
                await pool.query('SELECT 1 FROM docs_documents LIMIT 1');
                console.log('âœ… docs_documents table exists');
                
                await pool.query('SELECT 1 FROM docs_document_versions LIMIT 1');
                console.log('âœ… docs_document_versions table exists');
                
                await pool.query('SELECT 1 FROM docs_document_rollouts LIMIT 1');
                console.log('âœ… docs_document_rollouts table exists');
                
                await pool.query('SELECT 1 FROM docs_document_acknowledgments LIMIT 1');
                console.log('âœ… docs_document_acknowledgments table exists');
                
                console.log('âœ… Database schema verified');
              } catch (err) {
                console.error('âŒ Schema verification failed:', err.message);
                process.exit(1);
              } finally {
                await pool.end();
              }
            }
            verify();
          "

      - name: Check if database is seeded
        id: check-seeded
        run: |
          PSQL="psql-${{ env.APP_NAME }}-dev-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          # Check if default organization exists (indicates database is already seeded)
          ORG_EXISTS=$(node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            pool.query('SELECT id FROM core_organizations WHERE id = \$1', ['00000000-0000-0000-0000-000000000001'])
              .then(result => {
                console.log(result.rows.length > 0 ? 'true' : 'false');
                pool.end();
              })
              .catch(() => {
                console.log('false');
                pool.end();
              });
          ")
          echo "org_exists=$ORG_EXISTS" >> $GITHUB_OUTPUT
          if [ "$ORG_EXISTS" = "true" ]; then
            echo "âœ… Database already seeded, skipping seed step"
          else
            echo "ðŸŒ± Database not seeded, will run seed scripts"
          fi

      - name: Seed database (first time only)
        if: steps.check-seeded.outputs.org_exists != 'true'
        run: |
          PSQL="psql-${{ env.APP_NAME }}-dev-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          echo "ðŸŒ± Seeding RBAC system (includes admin user creation)..."
          pnpm db:seed-rbac
          echo "ðŸŒ± Seeding demo data..."
          pnpm db:seed || echo "âš ï¸ Demo data seeding skipped (optional)"
          echo "âœ… Database seeding completed"
          echo ""
          echo "ðŸ“‹ Admin credentials created:"
          echo "  Email: admin@example.com"
          echo "  Password: Admin123!"
          echo "  Role: Owner (full access)"

      - name: Sync RBAC permissions
        run: |
          PSQL="psql-${{ env.APP_NAME }}-dev-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          echo "ðŸ” Syncing RBAC modules and permissions..."
          pnpm db:sync-rbac
          echo "âœ… RBAC permissions synced"

      - name: Deploy to Container App
        id: deploy
        run: |
          RG="rg-${{ env.APP_NAME }}-dev-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          APP="${{ env.APP_NAME }}-dev"
          CAE="cae-${{ env.APP_NAME }}-dev"
          PSQL="psql-${{ env.APP_NAME }}-dev-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          IMAGE="${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ github.sha }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"

          # Use custom domain if configured, otherwise use Azure FQDN
          CUSTOM_DOMAIN="${{ vars.CUSTOM_DOMAIN }}"
          
          # Check if app exists
          if az containerapp show --resource-group $RG --name $APP > /dev/null 2>&1; then
            echo "Updating existing Container App..."
            # Get current FQDN for fallback
            FQDN=$(az containerapp show --resource-group $RG --name $APP --query "properties.configuration.ingress.fqdn" -o tsv)
            
            # Use custom domain if set, otherwise use Azure FQDN
            if [ -n "$CUSTOM_DOMAIN" ]; then
              APP_URL="https://$CUSTOM_DOMAIN"
              echo "Using custom domain: $APP_URL"
            else
              APP_URL="https://$FQDN"
              echo "Using Azure FQDN: $APP_URL"
            fi
            
            # Set ROOT_DOMAIN for multi-domain routing (strip 'app.' prefix if present)
            ROOT_DOMAIN="${CUSTOM_DOMAIN#app.}"
            
            az containerapp update \
              --name $APP \
              --resource-group $RG \
              --image $IMAGE \
              --set-env-vars \
                "NODE_ENV=production" \
                "DATABASE_URL=$DATABASE_URL" \
                "JWT_SECRET=${{ steps.secrets.outputs.jwt_secret }}" \
                "ENCRYPTION_KEY=${{ steps.secrets.outputs.encryption_key }}" \
                "NEXT_PUBLIC_APP_URL=$APP_URL" \
                "ROOT_DOMAIN=$ROOT_DOMAIN" \
                "APP_SUBDOMAIN=app"
          else
            echo "Creating new Container App..."
            az containerapp create \
              --name $APP \
              --resource-group $RG \
              --environment $CAE \
              --image $IMAGE \
              --registry-server ${{ secrets.ACR_NAME }}.azurecr.io \
              --registry-username ${{ steps.acr-creds.outputs.username }} \
              --registry-password ${{ steps.acr-creds.outputs.password }} \
              --target-port 3000 \
              --ingress external \
              --cpu 0.5 \
              --memory 1.0Gi \
              --min-replicas 1 \
              --max-replicas 3 \
              --env-vars \
                "NODE_ENV=production" \
                "DATABASE_URL=$DATABASE_URL" \
                "JWT_SECRET=${{ steps.secrets.outputs.jwt_secret }}" \
                "ENCRYPTION_KEY=${{ steps.secrets.outputs.encryption_key }}"
            
            # Get FQDN after creation
            FQDN=$(az containerapp show --resource-group $RG --name $APP --query "properties.configuration.ingress.fqdn" -o tsv)
            
            # Use custom domain if set, otherwise use Azure FQDN
            if [ -n "$CUSTOM_DOMAIN" ]; then
              APP_URL="https://$CUSTOM_DOMAIN"
            else
              APP_URL="https://$FQDN"
            fi
            
            # Update with APP_URL (needs second update after we know the FQDN)
            az containerapp update \
              --name $APP \
              --resource-group $RG \
              --set-env-vars "NEXT_PUBLIC_APP_URL=$APP_URL"
          fi

          # Output app URL
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          echo "Deployed to: $APP_URL"

  # ===========================================================================
  # Deploy to Staging (manual only)
  # ===========================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging'

    environment:
      name: staging
      url: ${{ steps.deploy.outputs.app_url }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: |
          az acr login --name ${{ secrets.ACR_NAME }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: deployment/docker/Dockerfile
          push: true
          tags: |
            ${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ github.sha }}
            ${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Get ACR credentials
        id: acr-creds
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query "passwords[0].value" -o tsv)
          echo "::add-mask::$ACR_PASSWORD"
          echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
          echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT

      - name: Get secrets from Key Vault
        id: secrets
        run: |
          KV_NAME="kv-${{ env.APP_NAME }}-staging-${{ env.SEQUENCE }}"
          JWT_SECRET=$(az keyvault secret show --vault-name $KV_NAME --name jwt-secret --query value -o tsv)
          ENCRYPTION_KEY=$(az keyvault secret show --vault-name $KV_NAME --name encryption-key --query value -o tsv)
          PG_PASSWORD=$(az keyvault secret show --vault-name $KV_NAME --name pg-password --query value -o tsv)
          echo "::add-mask::$JWT_SECRET"
          echo "::add-mask::$ENCRYPTION_KEY"
          echo "::add-mask::$PG_PASSWORD"
          echo "jwt_secret=$JWT_SECRET" >> $GITHUB_OUTPUT
          echo "encryption_key=$ENCRYPTION_KEY" >> $GITHUB_OUTPUT
          echo "pg_password=$PG_PASSWORD" >> $GITHUB_OUTPUT

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile

      - name: Push database schema
        env:
          CI: "true"
          FORCE_COLOR: "0"
          NODE_ENV: "production"
        run: |
          PSQL="psql-${{ env.APP_NAME }}-staging-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  IdaraOS Database Schema Push"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          # Prototyping mode: Drop all tables if schema mismatch detected
          echo "ðŸ” Checking for schema mismatches..."
          MISMATCH=$(node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            pool.query(\"SELECT column_name FROM information_schema.columns WHERE table_name = 'people_persons' AND column_name IN ('role', 'team')\")
              .then(r => { console.log(r.rows.length > 0 ? 'true' : 'false'); pool.end(); })
              .catch(() => { console.log('false'); pool.end(); });
          ")
          
          if [ "$MISMATCH" = "true" ]; then
            echo "âš ï¸  Old schema detected (role/team as text columns)"
            echo "ðŸ—‘ï¸  Dropping all tables for clean schema push (prototyping mode)..."
            node -e "
              const { Pool } = require('pg');
              const pool = new Pool({ connectionString: process.env.DATABASE_URL });
              pool.query('DROP SCHEMA public CASCADE; CREATE SCHEMA public;')
                .then(() => { console.log('Schema reset complete'); pool.end(); })
                .catch(e => { console.error('Error:', e.message); pool.end(); process.exit(1); });
            "
          fi
          
          echo "ðŸ“‹ Pushing schema to database (prototyping mode)..."
          # Install expect for handling interactive prompts
          sudo apt-get install -y expect > /dev/null 2>&1 || true
          
          # Use expect to handle drizzle-kit's interactive prompts
          expect -c '
            set timeout 300
            spawn npx drizzle-kit push --force
            expect {
              "truncate" { send "\r"; exp_continue }
              "Do you" { send "\r"; exp_continue }
              "?" { send "\r"; exp_continue }
              eof { exit 0 }
              timeout { exit 0 }
            }
          ' || true
          
          echo ""
          echo "âœ… Database schema push completed!"
          
      - name: Verify database schema
        run: |
          PSQL="psql-${{ env.APP_NAME }}-staging-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          
          echo "Verifying database schema..."
          node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            async function verify() {
              try {
                await pool.query('SELECT 1 FROM core_organizations LIMIT 1');
                console.log('âœ… core_organizations table exists');
                await pool.query('SELECT 1 FROM rbac_user_roles LIMIT 1');
                console.log('âœ… rbac_user_roles table exists');
                
                // Check people_persons has required columns
                const result = await pool.query(\`
                  SELECT column_name FROM information_schema.columns 
                  WHERE table_name = 'people_persons' 
                  AND column_name IN ('role_id', 'team_id', 'source', 'entra_created_at', 'hire_date')
                \`);
                const columns = result.rows.map(r => r.column_name);
                const required = ['role_id', 'team_id', 'source', 'entra_created_at', 'hire_date'];
                const missing = required.filter(c => !columns.includes(c));
                
                if (missing.length > 0) {
                  console.error('âŒ Missing columns in people_persons:', missing.join(', '));
                  process.exit(1);
                }
                
                // Check related tables exist
                await pool.query('SELECT 1 FROM people_teams LIMIT 1');
                console.log('âœ… people_teams table exists');
                
                await pool.query('SELECT 1 FROM people_organizational_roles LIMIT 1');
                console.log('âœ… people_organizational_roles table exists');
                
                console.log('âœ… people_persons has all required columns');
                
                // Check documentation tables exist
                await pool.query('SELECT 1 FROM docs_documents LIMIT 1');
                console.log('âœ… docs_documents table exists');
                
                await pool.query('SELECT 1 FROM docs_document_versions LIMIT 1');
                console.log('âœ… docs_document_versions table exists');
                
                await pool.query('SELECT 1 FROM docs_document_rollouts LIMIT 1');
                console.log('âœ… docs_document_rollouts table exists');
                
                await pool.query('SELECT 1 FROM docs_document_acknowledgments LIMIT 1');
                console.log('âœ… docs_document_acknowledgments table exists');
                
                console.log('âœ… Database schema verified');
              } catch (err) {
                console.error('âŒ Schema verification failed:', err.message);
                process.exit(1);
              } finally {
                await pool.end();
              }
            }
            verify();
          "

      - name: Check if database is seeded
        id: check-seeded
        run: |
          PSQL="psql-${{ env.APP_NAME }}-staging-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          # Check if default organization exists (indicates database is already seeded)
          ORG_EXISTS=$(node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            pool.query('SELECT id FROM core_organizations WHERE id = \$1', ['00000000-0000-0000-0000-000000000001'])
              .then(result => {
                console.log(result.rows.length > 0 ? 'true' : 'false');
                pool.end();
              })
              .catch(() => {
                console.log('false');
                pool.end();
              });
          ")
          echo "org_exists=$ORG_EXISTS" >> $GITHUB_OUTPUT
          if [ "$ORG_EXISTS" = "true" ]; then
            echo "âœ… Database already seeded, skipping seed step"
          else
            echo "ðŸŒ± Database not seeded, will run seed scripts"
          fi

      - name: Seed database (first time only)
        if: steps.check-seeded.outputs.org_exists != 'true'
        run: |
          PSQL="psql-${{ env.APP_NAME }}-staging-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          echo "ðŸŒ± Seeding RBAC system (includes admin user creation)..."
          pnpm db:seed-rbac
          echo "ðŸŒ± Seeding demo data..."
          pnpm db:seed || echo "âš ï¸ Demo data seeding skipped (optional)"
          echo "âœ… Database seeding completed"
          echo ""
          echo "ðŸ“‹ Admin credentials created:"
          echo "  Email: admin@example.com"
          echo "  Password: Admin123!"
          echo "  Role: Owner (full access)"

      - name: Sync RBAC permissions
        run: |
          PSQL="psql-${{ env.APP_NAME }}-staging-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          echo "ðŸ” Syncing RBAC modules and permissions..."
          pnpm db:sync-rbac
          echo "âœ… RBAC permissions synced"

      - name: Deploy to Container App
        id: deploy
        run: |
          RG="rg-${{ env.APP_NAME }}-staging-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          APP="${{ env.APP_NAME }}-staging"
          CAE="cae-${{ env.APP_NAME }}-staging"
          PSQL="psql-${{ env.APP_NAME }}-staging-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          IMAGE="${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ github.sha }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"

          # Use custom domain if configured, otherwise use Azure FQDN
          CUSTOM_DOMAIN="${{ vars.CUSTOM_DOMAIN }}"

          if az containerapp show --resource-group $RG --name $APP > /dev/null 2>&1; then
            FQDN=$(az containerapp show --resource-group $RG --name $APP --query "properties.configuration.ingress.fqdn" -o tsv)
            
            # Use custom domain if set, otherwise use Azure FQDN
            if [ -n "$CUSTOM_DOMAIN" ]; then
              APP_URL="https://$CUSTOM_DOMAIN"
              echo "Using custom domain: $APP_URL"
            else
              APP_URL="https://$FQDN"
              echo "Using Azure FQDN: $APP_URL"
            fi
            
            az containerapp update \
              --name $APP \
              --resource-group $RG \
              --image $IMAGE \
              --set-env-vars \
                "NODE_ENV=production" \
                "DATABASE_URL=$DATABASE_URL" \
                "JWT_SECRET=${{ steps.secrets.outputs.jwt_secret }}" \
                "ENCRYPTION_KEY=${{ steps.secrets.outputs.encryption_key }}" \
                "NEXT_PUBLIC_APP_URL=$APP_URL"
          else
            az containerapp create \
              --name $APP \
              --resource-group $RG \
              --environment $CAE \
              --image $IMAGE \
              --registry-server ${{ secrets.ACR_NAME }}.azurecr.io \
              --registry-username ${{ steps.acr-creds.outputs.username }} \
              --registry-password ${{ steps.acr-creds.outputs.password }} \
              --target-port 3000 \
              --ingress external \
              --cpu 0.5 \
              --memory 1.0Gi \
              --min-replicas 1 \
              --max-replicas 5 \
              --env-vars \
                "NODE_ENV=production" \
                "DATABASE_URL=$DATABASE_URL" \
                "JWT_SECRET=${{ steps.secrets.outputs.jwt_secret }}" \
                "ENCRYPTION_KEY=${{ steps.secrets.outputs.encryption_key }}"
            
            FQDN=$(az containerapp show --resource-group $RG --name $APP --query "properties.configuration.ingress.fqdn" -o tsv)
            
            # Use custom domain if set, otherwise use Azure FQDN
            if [ -n "$CUSTOM_DOMAIN" ]; then
              APP_URL="https://$CUSTOM_DOMAIN"
            else
              APP_URL="https://$FQDN"
            fi
            
            az containerapp update \
              --name $APP \
              --resource-group $RG \
              --set-env-vars "NEXT_PUBLIC_APP_URL=$APP_URL"
          fi

          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT

  # ===========================================================================
  # Deploy to Production (manual with approval)
  # ===========================================================================
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'

    environment:
      name: production
      url: ${{ steps.deploy.outputs.app_url }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: |
          az acr login --name ${{ secrets.ACR_NAME }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: deployment/docker/Dockerfile
          push: true
          tags: |
            ${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ github.sha }}
            ${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:prod-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Get ACR credentials
        id: acr-creds
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query "passwords[0].value" -o tsv)
          echo "::add-mask::$ACR_PASSWORD"
          echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
          echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT

      - name: Get secrets from Key Vault
        id: secrets
        run: |
          KV_NAME="kv-${{ env.APP_NAME }}-prod-${{ env.SEQUENCE }}"
          JWT_SECRET=$(az keyvault secret show --vault-name $KV_NAME --name jwt-secret --query value -o tsv)
          ENCRYPTION_KEY=$(az keyvault secret show --vault-name $KV_NAME --name encryption-key --query value -o tsv)
          PG_PASSWORD=$(az keyvault secret show --vault-name $KV_NAME --name pg-password --query value -o tsv)
          echo "::add-mask::$JWT_SECRET"
          echo "::add-mask::$ENCRYPTION_KEY"
          echo "::add-mask::$PG_PASSWORD"
          echo "jwt_secret=$JWT_SECRET" >> $GITHUB_OUTPUT
          echo "encryption_key=$ENCRYPTION_KEY" >> $GITHUB_OUTPUT
          echo "pg_password=$PG_PASSWORD" >> $GITHUB_OUTPUT

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile

      - name: Push database schema
        env:
          CI: "true"
          FORCE_COLOR: "0"
          NODE_ENV: "production"
        run: |
          PSQL="psql-${{ env.APP_NAME }}-prod-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  IdaraOS Database Schema Push"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          # Prototyping mode: Drop all tables if schema mismatch detected
          echo "ðŸ” Checking for schema mismatches..."
          MISMATCH=$(node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            pool.query(\"SELECT column_name FROM information_schema.columns WHERE table_name = 'people_persons' AND column_name IN ('role', 'team')\")
              .then(r => { console.log(r.rows.length > 0 ? 'true' : 'false'); pool.end(); })
              .catch(() => { console.log('false'); pool.end(); });
          ")
          
          if [ "$MISMATCH" = "true" ]; then
            echo "âš ï¸  Old schema detected (role/team as text columns)"
            echo "ðŸ—‘ï¸  Dropping all tables for clean schema push (prototyping mode)..."
            node -e "
              const { Pool } = require('pg');
              const pool = new Pool({ connectionString: process.env.DATABASE_URL });
              pool.query('DROP SCHEMA public CASCADE; CREATE SCHEMA public;')
                .then(() => { console.log('Schema reset complete'); pool.end(); })
                .catch(e => { console.error('Error:', e.message); pool.end(); process.exit(1); });
            "
          fi
          
          echo "ðŸ“‹ Pushing schema to database (prototyping mode)..."
          # Install expect for handling interactive prompts
          sudo apt-get install -y expect > /dev/null 2>&1 || true
          
          # Use expect to handle drizzle-kit's interactive prompts
          expect -c '
            set timeout 300
            spawn npx drizzle-kit push --force
            expect {
              "truncate" { send "\r"; exp_continue }
              "Do you" { send "\r"; exp_continue }
              "?" { send "\r"; exp_continue }
              eof { exit 0 }
              timeout { exit 0 }
            }
          ' || true
          
          echo ""
          echo "âœ… Database schema push completed!"
          
      - name: Verify database schema
        run: |
          PSQL="psql-${{ env.APP_NAME }}-prod-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          
          echo "Verifying database schema..."
          node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            async function verify() {
              try {
                await pool.query('SELECT 1 FROM core_organizations LIMIT 1');
                console.log('âœ… core_organizations table exists');
                await pool.query('SELECT 1 FROM rbac_user_roles LIMIT 1');
                console.log('âœ… rbac_user_roles table exists');
                
                // Check people_persons has required columns
                const result = await pool.query(\`
                  SELECT column_name FROM information_schema.columns 
                  WHERE table_name = 'people_persons' 
                  AND column_name IN ('role_id', 'team_id', 'source', 'entra_created_at', 'hire_date')
                \`);
                const columns = result.rows.map(r => r.column_name);
                const required = ['role_id', 'team_id', 'source', 'entra_created_at', 'hire_date'];
                const missing = required.filter(c => !columns.includes(c));
                
                if (missing.length > 0) {
                  console.error('âŒ Missing columns in people_persons:', missing.join(', '));
                  process.exit(1);
                }
                
                // Check related tables exist
                await pool.query('SELECT 1 FROM people_teams LIMIT 1');
                console.log('âœ… people_teams table exists');
                
                await pool.query('SELECT 1 FROM people_organizational_roles LIMIT 1');
                console.log('âœ… people_organizational_roles table exists');
                
                console.log('âœ… people_persons has all required columns');
                
                // Check documentation tables exist
                await pool.query('SELECT 1 FROM docs_documents LIMIT 1');
                console.log('âœ… docs_documents table exists');
                
                await pool.query('SELECT 1 FROM docs_document_versions LIMIT 1');
                console.log('âœ… docs_document_versions table exists');
                
                await pool.query('SELECT 1 FROM docs_document_rollouts LIMIT 1');
                console.log('âœ… docs_document_rollouts table exists');
                
                await pool.query('SELECT 1 FROM docs_document_acknowledgments LIMIT 1');
                console.log('âœ… docs_document_acknowledgments table exists');
                
                console.log('âœ… Database schema verified');
              } catch (err) {
                console.error('âŒ Schema verification failed:', err.message);
                process.exit(1);
              } finally {
                await pool.end();
              }
            }
            verify();
          "

      - name: Check if database is seeded
        id: check-seeded
        run: |
          PSQL="psql-${{ env.APP_NAME }}-prod-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          # Check if default organization exists (indicates database is already seeded)
          ORG_EXISTS=$(node -e "
            const { Pool } = require('pg');
            const pool = new Pool({ connectionString: process.env.DATABASE_URL });
            pool.query('SELECT id FROM core_organizations WHERE id = \$1', ['00000000-0000-0000-0000-000000000001'])
              .then(result => {
                console.log(result.rows.length > 0 ? 'true' : 'false');
                pool.end();
              })
              .catch(() => {
                console.log('false');
                pool.end();
              });
          ")
          echo "org_exists=$ORG_EXISTS" >> $GITHUB_OUTPUT
          if [ "$ORG_EXISTS" = "true" ]; then
            echo "âœ… Database already seeded, skipping seed step"
          else
            echo "ðŸŒ± Database not seeded, will run seed scripts"
          fi

      - name: Seed database (first time only)
        if: steps.check-seeded.outputs.org_exists != 'true'
        run: |
          PSQL="psql-${{ env.APP_NAME }}-prod-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          echo "ðŸŒ± Seeding RBAC system (includes admin user creation)..."
          pnpm db:seed-rbac
          echo "ðŸŒ± Seeding demo data..."
          pnpm db:seed || echo "âš ï¸ Demo data seeding skipped (optional)"
          echo "âœ… Database seeding completed"
          echo ""
          echo "ðŸ“‹ Admin credentials created:"
          echo "  Email: admin@example.com"
          echo "  Password: Admin123!"
          echo "  Role: Owner (full access)"

      - name: Sync RBAC permissions
        run: |
          PSQL="psql-${{ env.APP_NAME }}-prod-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"
          cd apps/web
          export DATABASE_URL
          echo "ðŸ” Syncing RBAC modules and permissions..."
          pnpm db:sync-rbac
          echo "âœ… RBAC permissions synced"

      - name: Deploy to Container App
        id: deploy
        run: |
          RG="rg-${{ env.APP_NAME }}-prod-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          APP="${{ env.APP_NAME }}-prod"
          CAE="cae-${{ env.APP_NAME }}-prod"
          PSQL="psql-${{ env.APP_NAME }}-prod-${{ env.LOCATION }}-${{ env.SEQUENCE }}"
          IMAGE="${{ secrets.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ github.sha }}"
          DATABASE_URL="postgresql://pgadmin:${{ steps.secrets.outputs.pg_password }}@${PSQL}.postgres.database.azure.com:5432/${{ env.APP_NAME }}?sslmode=require"

          # Use custom domain if configured, otherwise use Azure FQDN
          CUSTOM_DOMAIN="${{ vars.CUSTOM_DOMAIN }}"

          if az containerapp show --resource-group $RG --name $APP > /dev/null 2>&1; then
            FQDN=$(az containerapp show --resource-group $RG --name $APP --query "properties.configuration.ingress.fqdn" -o tsv)
            
            # Use custom domain if set, otherwise use Azure FQDN
            if [ -n "$CUSTOM_DOMAIN" ]; then
              APP_URL="https://$CUSTOM_DOMAIN"
              echo "Using custom domain: $APP_URL"
            else
              APP_URL="https://$FQDN"
              echo "Using Azure FQDN: $APP_URL"
            fi
            
            az containerapp update \
              --name $APP \
              --resource-group $RG \
              --image $IMAGE \
              --set-env-vars \
                "NODE_ENV=production" \
                "DATABASE_URL=$DATABASE_URL" \
                "JWT_SECRET=${{ steps.secrets.outputs.jwt_secret }}" \
                "ENCRYPTION_KEY=${{ steps.secrets.outputs.encryption_key }}" \
                "NEXT_PUBLIC_APP_URL=$APP_URL"
          else
            az containerapp create \
              --name $APP \
              --resource-group $RG \
              --environment $CAE \
              --image $IMAGE \
              --registry-server ${{ secrets.ACR_NAME }}.azurecr.io \
              --registry-username ${{ steps.acr-creds.outputs.username }} \
              --registry-password ${{ steps.acr-creds.outputs.password }} \
              --target-port 3000 \
              --ingress external \
              --cpu 1.0 \
              --memory 2.0Gi \
              --min-replicas 2 \
              --max-replicas 10 \
              --env-vars \
                "NODE_ENV=production" \
                "DATABASE_URL=$DATABASE_URL" \
                "JWT_SECRET=${{ steps.secrets.outputs.jwt_secret }}" \
                "ENCRYPTION_KEY=${{ steps.secrets.outputs.encryption_key }}"
            
            FQDN=$(az containerapp show --resource-group $RG --name $APP --query "properties.configuration.ingress.fqdn" -o tsv)
            
            # Use custom domain if set, otherwise use Azure FQDN
            if [ -n "$CUSTOM_DOMAIN" ]; then
              APP_URL="https://$CUSTOM_DOMAIN"
            else
              APP_URL="https://$FQDN"
            fi
            
            az containerapp update \
              --name $APP \
              --resource-group $RG \
              --set-env-vars "NEXT_PUBLIC_APP_URL=$APP_URL"
          fi

          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
